[
  {
    "question": "O que é o Rocket.Chat?",
    "answer": "O Rocket.Chat é uma plataforma de comunicações de código aberto, desenvolvida primariamente em TypeScript e projetada para ser totalmente personalizável. Seu foco principal são organizações com altos padrões de proteção e soberania de dados, permitindo que elas tenham total controle sobre suas conversas. A plataforma é utilizada por dezenas de milhões de usuários em mais de 150 países, incluindo entidades como a Marinha dos EUA (The US Navy), Deutsche Bahn e Credit Suisse.\n\nA plataforma oferece quatro produtos principais para atender a diferentes necessidades de comunicação:\n- **Colaboração em Equipe:** Centraliza a comunicação interna e entre empresas em um ambiente seguro.\n- **Atendimento ao Cliente Omnichannel:** Permite interações com clientes de forma integrada, independentemente do canal que eles utilizam (como chat de site, e-mail, WhatsApp, etc.).\n- **Mecanismo de Chat (Chat engine):** Oferece uma base para que desenvolvedores criem experiências de mensagens customizadas dentro de seus próprios aplicativos web ou móveis.\n- **Marketplace:** Disponibiliza um ecossistema de aplicativos e integrações nativas para expandir as funcionalidades da plataforma.\n\nUm dos principais diferenciais do Rocket.Chat é a flexibilidade nos modelos de implantação, refletindo sua missão de garantir a propriedade dos dados. As organizações podem optar por uma instalação auto-hospedada (*on-premise*), que pode ser implantada em seus próprios servidores, atrás de um firewall ou até mesmo em redes isoladas (*air-gapped*), garantindo controle total. Alternativamente, há uma opção de nuvem (SaaS) robusta e escalável, baseada em Docker e Kubernetes. Essa flexibilidade permite que a plataforma suporte conformidade com regulamentações rigorosas como GDPR, HIPAA e FedRAMP.\n\nNo dia a dia, a comunicação na plataforma ocorre em 'salas'. Os usuários podem enviar mensagens, que podem ser formatadas usando markdown para incluir negrito, itálico e blocos de código. É possível também fazer upload de arquivos, gravar e enviar mensagens de áudio e vídeo, compartilhar a localização e mencionar outros usuários para notificá-los. Essas funcionalidades podem ser configuradas pelo administrador do workspace, que pode, por exemplo, restringir o upload de certos tipos de arquivo."
  },
  {
    "question": "Qual linguagem principal do projeto?",
    "answer": "Com base na análise do repositório, a linguagem principal do projeto Rocket.Chat é o TypeScript.\n\nEle representa a esmagadora maioria do código-fonte, constituindo 92.8% de todo o projeto. Outras linguagens presentes em menor proporção incluem JavaScript (3.4%), CSS (2.3%) e HTML (1.0%).\n\nEssa informação é derivada da análise estatística do repositório principal, disponível em github.com/RocketChat/Rocket.Chat."
  },
  {
    "question": "Como posso contribuir para o projeto?",
    "answer": "Olá! Que ótimo que você tem interesse em contribuir diretamente com o código do projeto Rocket.Chat. O processo é bem estruturado para garantir a qualidade e a consistência da base de código.\n\nAqui está um guia focado no desenvolvedor, baseado exclusivamente nos documentos do repositório:\n\n### 1. Preparação: Configurando o Ambiente\n\nAntes de codificar, é essencial configurar seu ambiente de desenvolvimento corretamente. O projeto depende de versões muito específicas de suas ferramentas.\n\n- **Guias de Instalação:** Existem guias detalhadas para configurar o ambiente em **Linux/Windows (via WSL2)** e **macOS**. A forma mais rápida, que abstrai a configuração local, é usando o **Gitpod**.\n- **Versões de Dependências (Crítico):** Para evitar erros de compilação, você **deve** usar as versões exatas de Node.js, Deno e Meteor especificadas nos seguintes arquivos dentro do repositório:\n  - **Node.js:** Verifique a versão no arquivo `package.json`.\n  - **Deno:** Verifique a versão no arquivo `.tool-versions`.\n  - **Meteor:** Verifique a versão no arquivo `apps/meteor/.meteor/release`.\n- **Instalação e Execução:** Após clonar o repositório, o processo geral é instalar as dependências com o comando `yarn` e iniciar o servidor de desenvolvimento com `yarn dsv`.\n\n### 2. O Fluxo de Trabalho de Contribuição de Código\n\nO processo para que seu código seja integrado ao projeto segue um fluxo padrão do GitHub.\n\n#### Passo 1: Encontrar uma Tarefa e Comunicar\n\n- **Encontre uma tarefa:** A melhor forma de começar é procurar por `issues` abertas no repositório principal `RocketChat/Rocket.Chat`.\n- **Comunique sua intenção:** Antes de começar a trabalhar, é fundamental abrir uma nova `issue` para discutir a mudança proposta ou comentar em uma `issue` existente para informar que você está trabalhando nela. Isso garante que sua contribuição esteja alinhada com os planos do projeto.\n\n#### Passo 2: Codificar e Testar\n\n- **Fluxo Git:** O processo padrão é:\n  1. Fazer um **fork** do repositório `RocketChat/Rocket.Chat`.\n  2. Criar um novo **branch** para sua funcionalidade ou correção.\n  3. **Implementar** suas mudanças.\n- **Padrões de Código:** O projeto utiliza **TypeScript** e impõe um estilo de código consistente através de **ESLint** e **Prettier**.\n- **Testes:** É crucial que você execute os testes antes de submeter seu código. O projeto usa `husky` para rodar o `lint` e os testes unitários (`yarn testunit`) automaticamente antes de cada `push`, para evitar que a Integração Contínua (CI) falhe.\n\n#### Passo 3: Submeter sua Contribuição\n\n- **Assine o CLA (Contributor License Agreement):** Este é um passo **obrigatório**. Seu Pull Request (PR) não poderá ser integrado se você não assinar o CLA.\n- **Crie um Pull Request (PR):**\n  - O título do seu PR deve ser semântico (ex: `fix: corrige o login` ou `feat: adiciona nova funcionalidade`).\n  - Para novas funcionalidades ou correções, você deve adicionar um `changeset`.\n  - A descrição do PR deve ser detalhada, explicando o que foi feito e por quê.\n- **Revisão de Código:** A equipe do Rocket.Chat revisará seu PR. Esteja preparado para discussões e possíveis pedidos de alteração. A decisão final de integrar o código é da equipe.\n\n### 3. Código de Conduta\n\nToda a interação dentro da comunidade Rocket.Chat, incluindo o GitHub, é regida por um **Código de Conduta**. É importante lê-lo e segui-lo para manter um ambiente colaborativo e respeitoso."
  },
  {
    "question": "Quais são os principais produtos oferecidos?",
    "answer": "O Rocket.Chat é uma plataforma de comunicação de código aberto focada em proteção de dados. Seus produtos são divididos em quatro pilares principais, modelos de implantação e um ecossistema de aplicações.\n\n**Pilares de Produtos:**\n- **Colaboração de Equipe:** Hub seguro para comunicação interna e entre empresas.\n- **Atendimento ao Cliente Omnichannel:** Central de atendimento que integra múltiplos canais (chat de site, e-mail, redes sociais).\n- **Motor de Chat (Chat Engine):** Infraestrutura para desenvolvedores criarem experiências de chat personalizadas em seus próprios aplicativos.\n- **Marketplace:** Ecossistema de aplicativos e integrações para estender as funcionalidades da plataforma.\n\n**Modelos de Implantação e Planos:**\n- **Implantação:** Auto-hospedada (on-premise, incluindo air-gapped) ou na Nuvem (Cloud).\n- **Planos:**\n  - **Community:** Edição open-source (licença MIT) com funcionalidades essenciais.\n  - **Starter:** Acesso gratuito a recursos premium com limites de uso (até 50 usuários).\n  - **Pro:** Para equipes em crescimento, com maior capacidade de usuários e suporte.\n  - **Enterprise:** Solução completa para grandes organizações, com foco em escalabilidade, segurança e conformidade (licença proprietária).\n\n**Aplicações Cliente (Código Aberto):**\n- **Desktop (Electron):** Cliente para macOS, Windows e Linux. Permite personalização via `servers.json` e é licenciado sob MIT.\n- **Mobile (React Native):** Cliente para iOS e Android. Suporta \"whitelabeling\" para criar versões com marca própria e é licenciado sob MIT.\n\n**Plataforma para Desenvolvedores:**\n- **Apps-Engine:** Framework para construir e implantar aplicativos e integrações de forma segura em um ambiente sandbox.\n- **Apps-CLI:** Ferramenta de linha de comando para auxiliar no desenvolvimento de aplicativos."
  },
  {
    "question": "Existe uma versão cloud no Rocket.Chat?",
    "answer": "Sim, o Rocket.Chat oferece diversas opções de implantação em nuvem, que vão desde serviços totalmente gerenciados (SaaS) até a auto-hospedagem na sua própria infraestrutura de nuvem (IaaS).\n\nPara entender qual a melhor opção para você, é importante diferenciar os dois principais modelos:\n\n### 1. Hospedagem Gerenciada na Nuvem (SaaS)\n\nEsta é a opção mais próxima de um serviço de nuvem tradicional, onde a equipe do Rocket.Chat cuida de toda a infraestrutura, manutenção, escalabilidade e segurança. É ideal para quem busca conveniência e não quer gerenciar servidores.\n\nExistem duas modalidades principais, conforme descrito na documentação de implantação e nos planos de serviço:\n\n- **Premium Cloud Hosting:** Você utiliza um ambiente seguro e compartilhado (multi-tenant), com recursos pré-alocados e escalonamento automático para garantir a performance.\n- **Dedicated Cloud Hosting:** Oferece um ambiente totalmente dedicado e isolado (single-tenant) em Kubernetes, EC2 e MongoDB, garantindo performance máxima e maior controle sobre a configuração, incluindo a escolha da região de hospedagem.\n\nEssas opções de hospedagem gerenciada estão disponíveis para os planos **Pro** e **Enterprise**.\n\n### 2. Auto-hospedagem em Provedores de Nuvem (Self-managed on IaaS)\n\nNeste modelo, você implanta e gerencia o Rocket.Chat na sua própria conta de um provedor de nuvem, como Amazon Web Services (AWS) ou DigitalOcean. Você tem controle total sobre os dados e a infraestrutura, mas também é responsável pela sua gestão.\n\nO Rocket.Chat facilita esse processo através de:\n\n- **Instalações \"1-Click\" nos Marketplaces:** Tanto a AWS quanto a DigitalOcean oferecem imagens para uma implantação rápida. É importante notar que, neste caso, a instância é criada na *sua* conta, e você é o responsável por ela.\n- **Implantação com Docker e Kubernetes:** Estes são os métodos recomendados para implantações em nuvem, oferecendo escalabilidade e controle. O projeto mantém repositórios oficiais com templates para Docker Compose (`compose`) e Helm Charts (`helm-charts`) para facilitar a implantação.\n\nA opção de auto-hospedagem está disponível para todos os planos, incluindo o **Community** e o **Starter**.\n\n### O Portal \"Rocket.Chat Cloud\"\n\nÉ fundamental não confundir as opções de hospedagem com o **Portal Rocket.Chat Cloud** (`cloud.rocket.chat`). Este portal não é um serviço de hospedagem, mas sim uma ferramenta de gerenciamento centralizada à qual *todos* os workspaces, sejam auto-hospedados ou gerenciados na nuvem, devem se conectar. Ele é usado para registrar o workspace, gerenciar assinaturas de planos e sincronizar a licença, sendo essencial para o funcionamento de serviços como as notificações push.\n\nEm resumo, conforme destacado no `README.md` do repositório principal, o Rocket.Chat oferece tanto opções \"Self-hosted\" quanto \"Cloud\" , dando a flexibilidade para cada organização escolher o modelo que melhor se adapta às suas necessidades de controle, segurança e conveniência."
  },
  {
    "question": "Como instalar localmente para desenvolvimento?",
    "answer": "Para instalar o Rocket.Chat localmente para desenvolvimento, é necessário preparar o ambiente com as ferramentas e versões corretas e seguir uma sequência de comandos. O processo é detalhado nos guias de desenvolvimento do projeto.\n\n### 1. Pré-requisitos do Ambiente\n\nAntes de começar, garanta que sua máquina atende aos seguintes requisitos para evitar erros de compilação e execução. As informações foram extraídas dos guias de desenvolvimento para Linux e Windows (via WSL 2).\n\n- **Hardware**:\n  - **RAM**: Mínimo de 12 GB (16 GB ou mais é altamente recomendado).\n  - **CPU**: 4 núcleos ou mais.\n  - **Armazenamento**: 80 GB de SSD.\n- **Sistema Operacional**:\n  - Ubuntu ou Windows 10/11 com WSL 2 configurado.\n- **Ferramentas Essenciais**:\n  - `git`, `curl`, `unzip`, `make`, `build-essential`, `python3`, `g++`.\n- **Runtimes e Banco de Dados**:\n  - **Node.js**: A versão exata é crucial. A fonte mais confiável é a página de **GitHub Releases** do projeto. Recomenda-se usar o `nvm` (Node Version Manager) para instalar a versão especificada no release mais recente.\n  - **Deno**: Assim como o Node.js, a versão exata deve ser verificada na página de **GitHub Releases**.\n  - **Meteor**: A versão correta pode ser confirmada diretamente no arquivo `apps/meteor/.meteor/release` dentro do repositório clonado.\n  - **MongoDB**: As versões compatíveis estão listadas na seção \"Engine versions\" da página de **GitHub Releases**.\n  - **Yarn**: É o gerenciador de pacotes recomendado para instalar as dependências do projeto.\n\n### 2. Passos para Instalação (Linux / Windows com WSL 2)\n\nExecute os seguintes comandos no seu terminal. Para Windows, todos os comandos devem ser executados dentro do shell do Ubuntu no WSL 2.\n\n#### Faça o Fork e Clone do Repositório\nO processo de contribuição padrão começa com um fork, que é uma cópia pessoal do projeto. Você trabalhará no seu fork.\n\n```bash\n# Clone o seu fork do repositório (substitua <seu-usuario>)\ngit clone https://github.com/<seu-usuario>/Rocket.Chat.git\n\n# Navegue para o diretório do projeto\ncd Rocket.Chat\n```\n\n#### Instale as Ferramentas de Build do Sistema\nGaranta que seu sistema operacional tenha os pacotes essenciais para compilação.\n\n```bash\n# (Para Debian/Ubuntu) Atualize os pacotes e instale as ferramentas\nsudo apt update && sudo apt dist-upgrade -y\nsudo apt install git curl unzip make build-essential python3 g++\n```\n\nEste passo é fundamental e está descrito no guia de configuração de ambiente.\n\n#### Instale as Dependências do Projeto\nCom os runtimes (Node.js, Deno, Meteor) já instalados nas versões corretas, use o `yarn` para instalar todas as dependências do Node.js.\n\n```bash\n# Instala todas as dependências listadas no package.json\nyarn\n```\n\n#### Execute o Servidor de Desenvolvimento\nApós a instalação das dependências, inicie o servidor. Este comando cuidará de iniciar o MongoDB e o servidor Meteor.\n\n```bash\n# Inicia o servidor de desenvolvimento\nyarn dsv\n```\n\nA primeira compilação pode demorar um tempo considerável. Avisos sobre dependências (`peer dependencies`) são comuns e geralmente podem ser ignorados. Após a conclusão, a aplicação estará rodando em `http://localhost:3000`.\n\n### Alternativa: Gitpod\n\nPara uma configuração mais rápida e que evita a complexidade do ambiente local, o projeto recomenda o uso do Gitpod. Ele fornece um ambiente de desenvolvimento na nuvem, pré-configurado e acessível pelo navegador. O processo envolve fazer o fork do repositório e abri-lo com o Gitpod."
  },
  {
    "question": "Como funciona a autenticação?",
    "answer": "A autenticação no Rocket.Chat é um sistema modular e extensível, projetado para oferecer flexibilidade, desde o login básico com nome de usuário e senha até integrações complexas de Single Sign-On (SSO) como SAML e OAuth, além da integração com diretórios corporativos via LDAP.\n\nAqui está um detalhamento de como cada método funciona:\n\n### 1. Autenticação Padrão (Usuário e Senha)\n\nEsta é a forma mais fundamental de autenticação.\n\n- **Fluxo de Login:** A autenticação é realizada principalmente através do endpoint da API REST `POST /api/v1/login`. A requisição deve conter o `user` (que pode ser o nome de usuário ou e-mail) e a `password`. Em caso de sucesso, a API retorna um `authToken` e um `userId`, que devem ser usados nos cabeçalhos `X-Auth-Token` e `X-User-Id` para autenticar requisições subsequentes a endpoints protegidos.\n- **Políticas de Senha:** Administradores podem definir políticas de senha rigorosas, como comprimento mínimo/máximo e a exigência de caracteres específicos, na área de `Administração > Workspace > Configurações > Contas > Política de Senha`.\n- **Redefinição de Senha:** O processo é iniciado na tela de login. Um problema conhecido em algumas versões (como 4.8.1 e 5.1) é que, após o usuário redefinir a senha com sucesso, a interface exibe uma mensagem de \"Token expirado\", embora a senha tenha sido alterada corretamente no backend. O usuário pode ignorar o erro e fazer login com a nova senha."
  },
  {
    "question": "Quais frameworks ou tecnologias são usados?",
    "answer": "Olá! O ecossistema do Rocket.Chat é bastante abrangente e utiliza uma variedade de tecnologias e frameworks modernos, cada um escolhido para um propósito específico. A arquitetura é estruturada como um **monorepo**, o que facilita o gerenciamento de múltiplos projetos interligados.\n\n### Estrutura do Projeto e Ferramentas Principais\n\n- **Monorepo com Turbo:** O projeto é um monorepo gerenciado pelo **Turbo**, que atua como o orquestrador de build e tarefas. Isso é visível nos scripts do `package.json` principal, como \"build\": \"turbo run build\".\n- **Yarn Package Manager:** O gerenciador de pacotes padrão é o **Yarn**. O arquivo `package.json` na raiz especifica a versão do Yarn a ser usada e até mesmo bloqueia o uso do npm. A presença de arquivos como `yarn.lock` e menções a `.pnp.js` no `.gitignore` confirmam seu uso.\n- **Node.js e TypeScript:** O ambiente de desenvolvimento é padronizado em **Node.js**. A linguagem primária em todo o ecossistema é o **TypeScript**, evidenciado pela grande quantidade de arquivos `tsconfig.json` e pelas estatísticas de linguagem nos repositórios.\n\n### Aplicação Principal (Servidor e Cliente Web)\n\n- **Meteor.js:** O coração do servidor Rocket.Chat é construído sobre o framework full-stack **Meteor.js**. Isso é explicitamente mencionado na documentação e confirmado pelos scripts no `package.json` do pacote principal (`apps/meteor`), que invocam o comando `meteor` para iniciar a aplicação.\n- **React e Fuselage (UI Kit):** O cliente web, que é servido diretamente pela aplicação Meteor, utiliza **React** para sua interface. A biblioteca de componentes de UI é o **Fuselage**, o sistema de design proprietário do Rocket.Chat, que também é um repositório destacado na organização. As notas de lançamento frequentemente mencionam atualizações no pacote `@rocket.chat/fuselage-ui-kit`.\n\n### Clientes Dedicados\n\nO Rocket.Chat oferece clientes para múltiplas plataformas, cada um com sua própria pilha tecnológica:\n\n- **Cliente Desktop (Electron):** Os clientes para macOS, Windows e Linux são desenvolvidos com **Electron**. O repositório `Rocket.Chat.Electron` detalha o uso de **Gulp** como executor de tarefas, **Rollup** como empacotador de módulos e **electron-builder** para criar os instaladores.\n- **Cliente Mobile (React Native):** Para iOS e Android, a plataforma utiliza **React Native**, proporcionando uma experiência mais próxima da nativa. O repositório `Rocket.Chat.ReactNative` mostra uma base de código predominantemente em **TypeScript**, com módulos nativos em **Swift**, **Java** e **Kotlin** para funcionalidades específicas da plataforma. Esta abordagem substituiu uma versão anterior baseada em Cordova, que agora está obsoleta.\n\n### Extensibilidade (Apps-Engine)\n\n- **Node.js VM e Deno:** O **Apps-Engine** é o framework que permite a criação de aplicativos e integrações. A documentação oficial menciona que ele utiliza o módulo `vm` do **Node.js** para executar o código dos aplicativos em um ambiente seguro e isolado (sandbox). No entanto, uma análise do código-fonte no repositório `Rocket.Chat.Apps-engine` revela a existência de um `deno-runtime` e commits relacionados à introdução de um novo runtime baseado em **Deno**. Isso sugere uma transição arquitetural em andamento para um ambiente de execução mais moderno e seguro por padrão.\n\n### Testes e Qualidade de Código\n\nA plataforma possui uma suíte de testes robusta:\n\n- **Testes End-to-End (E2E):** Utiliza-se o **Playwright** para os testes E2E da interface web, conforme definido no script `test:e2e` do pacote Meteor. Para o cliente Electron, os testes E2E são feitos com **Spectron**.\n- **Testes de Unidade e API:** O framework **Mocha** é usado para testes de unidade e de API no backend. O cliente Electron também usa um executor baseado em Mocha (`electron-mocha`) com a biblioteca de asserções **Chai**.\n- **Linting:** **ESLint** e **Stylelint** são usados para garantir a consistência e a qualidade do código em todo o projeto.\n\n### DevOps e Implantação\n\n- **Docker:** O projeto tem amplo suporte para implantação via **Docker** e **Docker Compose**, com imagens oficiais disponíveis e documentação detalhada para configuração.\n- **CI/CD com GitHub Actions:** A integração e entrega contínua são automatizadas através de **GitHub Actions**, com diversos workflows definidos no diretório `.github/workflows` para testes, builds e releases.\n\nEm resumo, o Rocket.Chat é um ecossistema complexo que combina a estabilidade do Meteor.js em seu núcleo com tecnologias de cliente modernas como React Native e Electron, tudo orquestrado por um ferramental de monorepo de ponta e suportado por práticas de DevOps e testes automatizados."
  },
  {
    "question": "Como é feita a gestão de apps?",
    "answer": "A gestão de aplicações (apps) no Rocket.Chat é um processo estruturado que se baseia no **Apps-Engine**, um framework robusto que permite estender as funcionalidades da plataforma de forma segura. O gerenciamento abrange desde o desenvolvimento e distribuição até a instalação, configuração e governança de permissões.\n\nA seguir, detalho as principais etapas e conceitos da gestão de apps no ecossistema Rocket.Chat.\n\n### 1. A Base Tecnológica: O Apps-Engine\n\nToda a extensibilidade do Rocket.Chat é construída sobre o Apps-Engine.\n\n- **O que é?** É o framework oficial, desenvolvido em TypeScript, para a criação de apps. Ele garante que as aplicações rodem em um ambiente isolado (sandbox), fornecendo APIs para interagir de forma controlada com o sistema principal do Rocket.Chat. O código-fonte do engine, que antes era um repositório separado, agora reside dentro do monorepo principal do Rocket.Chat, no diretório `packages/apps-engine`, para facilitar o desenvolvimento integrado.\n- **Capacidades:** O Apps-Engine permite que um app:\n  - **Reaja a eventos:** Ouça eventos como o envio ou exclusão de mensagens e a criação de salas.\n  - **Crie interações:** Registre comandos de barra (slash commands), como `/github issue`, e crie interfaces de usuário interativas, como modais e barras de contexto, usando o **UIKit**.\n  - **Comunique-se externamente:** Registre endpoints de API para receber dados de serviços externos (webhooks) e faça requisições HTTP para outras plataformas.\n  - **Armazene dados e configurações:** Utilize um sistema de armazenamento de chave-valor e defina configurações que os administradores podem gerenciar pela interface.\n\n### 2. Aquisição e Instalação de Apps\n\nOs administradores podem instalar apps de duas fontes principais: o Marketplace público e uploads privados.\n\n- **Marketplace:** É o hub central para descobrir e instalar apps públicos.\n  - **Acesso:** O caminho na interface de administração é `Administração > Apps > Marketplace`.\n  - **Pré-requisitos:** Para acessar o Marketplace, o workspace precisa estar registrado no Rocket.Chat Cloud, mesmo em planos comunitários (gratuitos). Além disso, se houver um firewall, o domínio `marketplace.rocket.chat` deve ser liberado.\n  - **Disponibilidade por Plano:** Muitas aplicações, especialmente as voltadas para o ambiente corporativo, são exclusivas de planos pagos (Starter, Pro, Enterprise). O plano Community possui um limite no número de apps que podem ser habilitados simultaneamente.\n\n- **Apps Privados:** São soluções customizadas, desenvolvidas para um workspace específico.\n  - **Instalação:** O app é empacotado como um arquivo `.zip` e carregado manualmente pelo administrador em `Administração > Marketplace > Private Apps`.\n  - **Restrições de Plano:** A partir da versão 7.0 do Rocket.Chat, a instalação de novos apps privados é uma funcionalidade restrita a workspaces em planos premium. Workspaces no plano Community que já possuíam apps privados instalados antes dessa versão podem continuar a usá-los, mas se um app for desinstalado, não poderá ser reinstalado.\n\n### 3. Administração e Governança\n\nApós a instalação, a gestão contínua do app é feita através da interface de administração e de um modelo de permissões de dupla camada.\n\n- **Gerenciamento na Interface:** No painel de administração, um administrador pode executar as seguintes ações em um app instalado:\n  - **Habilitar/Desabilitar:** Ativar ou desativar um app sem removê-lo.\n  - **Desinstalar:** Remover completamente o app e seus dados.\n  - **Configurar:** Acessar a página de configurações do app para inserir chaves de API, tokens, etc.\n  - **Visualizar Logs:** Acessar a aba de \"Logs\" na página de detalhes do app, uma ferramenta crucial para depuração.\n\n- **Modelo de Permissões:** A segurança é garantida por dois níveis de permissão:\n  1. **Permissões de Usuário (RBAC):** Controlam *quem pode gerenciar os apps*. A permissão principal é a `access-marketplace`, que por padrão é concedida à role de `admin`. Essas permissões são gerenciadas em `Administração > Workspace > Permissions`.\n  2. **Permissões do App (Manifesto):** Controlam *o que o app pode fazer no sistema*. Cada app deve declarar as permissões que necessita em seu arquivo de manifesto, o `app.json`. Por exemplo, para adicionar um botão na interface, o app precisa da permissão `{\"name\": \"ui.registerButtons\"}`. Durante a instalação, o administrador visualiza e deve consentir com a lista de permissões solicitadas, garantindo que o app só terá acesso às funcionalidades aprovadas.\n\n### 4. Exemplo Prático: Gestão do App do GitHub\n\nO processo de gestão do app oficial do GitHub ilustra bem o fluxo completo:\n\n1. **Instalação:** O administrador encontra o app \"GitHub\" no Marketplace e clica em \"Instalar\".\n2. **Configuração (OAuth):** Após a instalação, o app precisa ser conectado ao GitHub. Isso é feito na aba \"Settings\" do app:\n  - O administrador copia a `Authorization callback URL` fornecida pelo app no Rocket.Chat.\n  - Ele vai até as configurações de desenvolvedor no GitHub, cria um novo \"OAuth App\" e cola a URL de callback.\n  - O GitHub gera um `Client ID` e um `Client Secret`.\n  - O administrador copia essas credenciais e as cola de volta nos campos correspondentes nas configurações do app no Rocket.Chat e salva.\n3. **Uso:** Com o app configurado, os usuários do workspace podem interagir com ele.\n  - Primeiro, cada usuário precisa autenticar sua própria conta usando o comando `/github login`.\n  - Depois, eles podem usar outros comandos para interagir com o GitHub diretamente do chat, como `/github issue` para criar uma nova issue, `/github search` para procurar issues e pull requests, e `/github subscribe` para receber notificações de um repositório."
  },
  {
    "question": "Onde encontro a documentação sobre APIs?",
    "answer": "Claro! A documentação da API do Rocket.Chat é distribuída em vários locais especializados, dependendo do seu objetivo. Aqui está um guia para encontrar exatamente o que você precisa:\n\n### 1. Documentação Interativa da API REST (Fonte Principal)\n\nPara a maioria dos desenvolvedores, o melhor lugar para começar é o portal oficial de desenvolvedores. Lá você encontra a documentação da API REST completa, de forma interativa e fácil de navegar, com exemplos de parâmetros e respostas.\n\n- **Portal de Desenvolvedores:** A documentação interativa da API está hospedada em `developer.rocket.chat`. Um exemplo pode ser visto em `developer.rocket.chat/apidocs/directory-1`.\n- **Contexto:** O projeto migrou sua documentação para portais dedicados para oferecer uma experiência melhor, preterindo a documentação estática que existia anteriormente em repositórios do GitHub. A informação pode ser encontrada no repositório `RocketChat/developer-docs`.\n\n### 2. Especificações Formais da API (OpenAPI/Swagger)\n\nSe você precisa da especificação formal da API para gerar um cliente em uma linguagem específica (como Python, Go, etc.) ou para ferramentas de automação, o repositório `Rocket.Chat-Open-API` é a fonte definitiva.\n\n- **Repositório:** `RocketChat/Rocket.Chat-Open-API`\n- **Conteúdo:** Este repositório contém arquivos `YAML` do OpenAPI (Swagger) que descrevem formalmente todos os endpoints da API REST, organizados por categorias como Autenticação, Mensagens, Salas, Omnichannel, entre outros.\n\n### 3. SDKs (Software Development Kits)\n\nPara uma integração mais fácil e idiomática em linguagens específicas, o Rocket.Chat oferece SDKs. A documentação deles está localizada dentro de seus próprios repositórios.\n\n- **JavaScript/Node.js SDK (`@rocket.chat/sdk`):**\n  - **Repositório:** `RocketChat/Rocket.Chat.js.SDK`\n  - **Documentação:** O arquivo `README.md` deste repositório serve como a documentação principal. Ele detalha os dois módulos essenciais:\n    - `api`: Para fazer requisições à API REST (`api.get`, `api.post`).\n    - `driver`: Para interação em tempo real via DDP, como se inscrever em streams de mensagens (`driver.subscribeToMessages`). É fundamental para o desenvolvimento de bots.\n\n- **Java SDK:**\n  - **Repositório:** `RocketChat/Rocket.Chat.Java.SDK`\n  - **Documentação:** A documentação está no arquivo `docs/ROCKETCHAT_API.md` dentro deste repositório. Ele detalha métodos como `login`, `getChatRoomFactory` e `createPublicGroup`.\n\n**Observação Importante:**\nA documentação da API **não se encontra** no repositório principal `RocketChat/Rocket.Chat`. Esse repositório contém o código-fonte da aplicação do servidor, e não a documentação para desenvolvedores que criam integrações."
  },
  {
    "question": "Qual é a licença do projeto?",
    "answer": "O projeto Rocket.Chat opera em um modelo de licenciamento duplo, frequentemente chamado de \"open core\".\n\n1. **Licença do Código-Fonte (Open Source):**\n    O núcleo do projeto é totalmente open-source e distribuído sob a **licença MIT**. Esta é uma licença permissiva que concede a você o direito de usar, copiar, modificar, mesclar, publicar, distribuir e até mesmo vender cópias do software com poucas restrições. A confirmação desta licença pode ser encontrada diretamente no repositório do projeto:\n    - No arquivo `LICENSE` na raiz do repositório.\n    - Declarada no campo `license` do arquivo `package.json`.\n\n2. **Licenças Comerciais para Recursos Premium:**\n    Para acessar funcionalidades avançadas, projetadas para equipes em crescimento e grandes corporações (como opções avançadas de auditoria, alta escalabilidade, suporte dedicado e remoção da marca d'água), o Rocket.Chat oferece planos de assinatura comerciais. Esses planos (como **Starter**, **Pro** e **Enterprise**) funcionam através de uma licença comercial que é aplicada à sua instância (workspace) para desbloquear esses recursos. O plano Starter, por exemplo, oferece acesso a quase todos os recursos premium gratuitamente, mas com limites de uso (até 25 usuários).\n\nEm resumo, você pode baixar, usar e modificar o código-fonte gratuitamente sob a licença MIT (o que corresponde à edição **Community**), mas para utilizar o conjunto completo de funcionalidades premium em produção, especialmente em escala, é necessário adquirir uma licença de um dos planos comerciais."
  },
  {
    "question": "Quantas estrelas e forks o repositório tem?",
    "answer": "De acordo com as informações disponíveis, o repositório principal do projeto, `RocketChat/Rocket.Chat`, possui **43.076 estrelas** e **11.990 forks**.\n\nEssas métricas refletem a popularidade e o engajamento da comunidade de desenvolvedores com a plataforma."
  },
  {
    "question": "Há apps móveis oficiais?",
    "answer": "Sim, o projeto Rocket.Chat possui aplicativos móveis oficiais para as plataformas iOS e Android.\n\nA confirmação pode ser encontrada em várias fontes oficiais do projeto:\n\n1. **Repositório no GitHub**: A organização Rocket.Chat no GitHub destaca o repositório `Rocket.Chat.ReactNative`, com a descrição \"Rocket.Chat mobile clients\". Este é o repositório central para o desenvolvimento dos aplicativos móveis.\n\n2. **Documentação Oficial**: A documentação do Rocket.Chat fornece instruções de instalação e links diretos para as lojas de aplicativos:\n    - **Android**:(https://play.google.com/store/apps/details?id=chat.rocket.android).\n    - **iOS**:(https://apps.apple.com/us/app/rocket-chat/id1148741252).\n\n3. **Página de Lançamentos (Releases)**: Na página de `releases` do repositório `Rocket.Chat.ReactNative`, é possível encontrar e baixar os arquivos de compilação oficiais, como `android-official-release.apk` e `ios-official-release.ipa`.\n\n### Detalhes Técnicos\n\nOs aplicativos são desenvolvidos utilizando a framework **React Native**, o que permite manter uma base de código majoritariamente unificada para ambas as plataformas. A linguagem principal do repositório é **TypeScript (88.5%)**, mas também inclui código nativo em **Swift (4.6%)** e **Java (1.5%)** para funcionalidades específicas de cada sistema operacional.\n\nO `README.md` do repositório especifica os seguintes requisitos mínimos de sistema operacional:\n- **iOS**: `13.4+` \n- **Android**: `6.0+` \n\nÉ importante não confundir os aplicativos cliente (móvel e desktop) com os \"Apps\" de integração disponíveis no marketplace do Rocket.Chat, como o app do GitHub, que serve para estender as funcionalidades do servidor com notificações e comandos."
  },
  {
    "question": "Onde posso pedir suporte ou participar da comunidade?",
    "answer": "Olá! Fico feliz em ajudar. Para pedir suporte e participar da comunidade Rocket.Chat, você tem diversos canais à disposição, cada um com um propósito específico. A escolha do canal ideal depende da sua necessidade.\n\n### Para Suporte e Discussões\n\n1. **Servidor da Comunidade (Tempo Real):** A forma mais direta de obter ajuda é através do servidor da comunidade oficial. O arquivo `README.md` do repositório principal menciona que o servidor conta com milhares de membros e recomenda os canais `#support` e `#general` para suporte.\n\n2. **Fóruns da Comunidade (Discussões Especializadas):** Para tópicos mais aprofundados, especialmente sobre o desenvolvimento de Apps, os fóruns são o lugar certo. O `README.md` do repositório `Apps.GitHub` aponta para os fóruns para guias e solicitações de apps.\n\n3. **GitHub Discussions:** Para conversas mais amplas sobre o projeto, ideias ou dúvidas de arquitetura que não se encaixam como um bug ou feature request, você pode usar a aba \"Discussions\" na organização do Rocket.Chat no GitHub.\n\n### Para Participar Ativamente e Contribuir\n\nA participação na comunidade está fortemente ligada à contribuição para o projeto através do GitHub.\n\n1. **Reportando Bugs e Sugerindo Ideias (GitHub Issues):** Este é o principal ponto de partida para contribuições. O arquivo `.github/CONTRIBUTING.md` incentiva que, antes de tudo, você \"abra uma issue e inicie uma conversa\" para relatar bugs ou discutir novas funcionalidades. Para propostas formais de novas funcionalidades, o `README.md` principal indica o uso do repositório específico `Rocket.Chat/feature-requests`.\n\n2. **Contribuindo com Código (Pull Requests):** Se você deseja contribuir diretamente com código, o processo é bem documentado. O guia em `developer.rocket.chat/docs/contribution-process` detalha o passo a passo, que envolve fazer um fork, criar uma branch, implementar as mudanças e submeter um Pull Request para revisão. É importante notar que, conforme o `.github/CONTRIBUTING.md`, é obrigatório assinar o Contributor License Agreement (CLA) para que sua contribuição seja aceita.\n\n3. **Outras Formas de Contribuição:** Mesmo sem programar, você pode ajudar. A documentação do aplicativo móvel menciona que fazer a triagem de issues é uma ótima forma de contribuir. Além disso, o arquivo `.github/CONTRIBUTING.md` sugere que você pode ajudar corrigindo erros de digitação na documentação, escrevendo sobre o projeto em blogs ou simplesmente ajudando a divulgá-lo.\n\nEm resumo, para dúvidas rápidas, use o servidor da comunidade. Para contribuições, comece com uma **Issue** no GitHub."
  },
  {
    "question": "Como reportar uma vulnerabilidade de segurança?",
    "answer": "Para reportar uma vulnerabilidade de segurança no Rocket.Chat, você deve seguir os canais de divulgação privada estabelecidos pelo projeto para garantir que a informação seja tratada de forma segura e responsável.\n\nA documentação de segurança, encontrada no arquivo `SECURITY.md` do repositório, descreve dois métodos principais :\n\n1. **Programa de Bug Bounty (HackerOne)**: O método preferencial é submeter o seu relatório através do programa de Bug Bounty e Divulgação de Vulnerabilidades (VDP) na plataforma HackerOne.\n\n2. **E-mail Direto**: Como alternativa, você pode enviar um e-mail detalhado para `security@rocket.chat`. Este canal também é confirmado em outros repositórios do projeto, como o do `Rocket.Chat.ReactNative`.\n\nAo enviar seu relatório, é crucial incluir o máximo de informações possível para ajudar a equipe a validar e corrigir a falha. A política de segurança recomenda fornecer os seguintes detalhes :\n\n- **Descrição**: Uma explicação clara da vulnerabilidade.\n- **Versão Afetada**: A versão ou versões do Rocket.Chat que são impactadas.\n- **Passos para Reproduzir**: Instruções detalhadas que permitam à equipe recriar o problema.\n- **Impacto Identificado**: Uma análise do que a vulnerabilidade permite que um invasor faça.\n- **Prova de Conceito (PoC)**: Um exemplo funcional que demonstre a exploração da vulnerabilidade.\n\nÉ importante notar que, no momento, o projeto não oferece recompensas monetárias por vulnerabilidades reportadas. O processo de contribuição pública via Pull Requests não deve ser usado para relatar problemas de segurança."
  },
  {
    "question": "Quais requisitos para deployment?",
    "answer": "Para fazer o deploy do Rocket.Chat, você precisa atender a uma série de requisitos que se dividem em quatro áreas principais: Hardware, Software, Métodos de Implantação e Rede/Segurança. É crucial usar uma versão recente e suportada, pois desde 15 de dezembro de 2023, versões legadas perderam o acesso a serviços essenciais da nuvem, como notificações push e aplicativos oficiais.\n\nAqui está um detalhamento completo dos requisitos com base na documentação oficial do projeto.\n\n### 1. Requisitos de Hardware\n\nO dimensionamento do hardware depende do número de usuários simultâneos e do tipo de ambiente (produção ou desenvolvimento).\n\n**Ambientes de Produção (Autogerenciado):**\nAs especificações variam conforme o plano e a quantidade de usuários. A recomendação oficial é :\n\n| Cenário (Usuários Simultâneos) | Componente | vCPU | Memória (GiB) | Armazenamento (GB) |\n|---|---|---|---|---|\n| **Starter (≤ 50)** | Rocket.Chat | 1 | 2 | 40 |\n| | MongoDB | 2 | 2 | 10 |\n| **Pro (< 500)** | Rocket.Chat | 2 | 4 | 40 |\n| | MongoDB | 2 | 4 | 20 |\n| **Enterprise (500 a 5000)** | Rocket.Chat | 4-16 | 4-12 | 40 |\n| | MongoDB | 2-8 | 4-16 | 20-80 |\n\nPara implantações com alta disponibilidade (planos Pro e Enterprise), é necessário um replica set do MongoDB com 3 membros.\n\n**Requisito Crítico de CPU (MongoDB):**\nAs versões recentes do Rocket.Chat (7.x) exigem MongoDB 5.0 ou superior. O MongoDB 5.0+ **requer uma CPU que suporte o conjunto de instruções AVX (Advanced Vector Extensions)**. Hardware mais antigo ou de baixo consumo (como alguns processadores Intel Atom) pode não ter esse suporte, impedindo a instalação ou atualização. Verifique a compatibilidade da sua CPU antes de iniciar.\n\n**Ambiente de Desenvolvimento:**\nSe você for compilar o projeto a partir do código-fonte, os requisitos são maiores:\n- **RAM:** Mínimo de 12 GB, recomendado 16 GB ou mais.\n- **CPU:** 4 ou mais núcleos.\n- **Armazenamento:** SSD rápido para otimizar o tempo de compilação.\n\nEsses requisitos estão detalhados no guia de ambiente de desenvolvimento para Linux e Windows.\n\n### 2. Dependências de Software\n\nA compatibilidade de versões entre o Rocket.Chat, MongoDB e as ferramentas de desenvolvimento é estrita.\n\n**Versão do MongoDB:**\nCada versão do Rocket.Chat suporta uma faixa específica de versões do MongoDB. Usar uma combinação incorreta pode causar instabilidade.\n\n| Versão do Rocket.Chat | Versões Suportadas do MongoDB |\n|---|---|\n| 4.x | 3.6, 4.0, 4.2, 4.4, 5.0 |\n| 5.x | 4.2, 4.4, 5.0 |\n| 6.x | 4.4, 5.0, 6.0 |\n| 7.x | 5.0, 6.0, 7.0 |\n\nVocê pode verificar a versão exata para uma release específica consultando a seção \"Engine versions\" nas **notas de lançamento do GitHub** (ex: `https://github.com/RocketChat/Rocket.Chat/releases/<VERSAO>`) ou usando a API de releases. A tabela completa de compatibilidade pode ser encontrada na documentação de pré-requisitos de suporte.\n\n**Ferramentas de Desenvolvimento (Build a partir do código-fonte):**\nÉ mandatório usar as versões exatas das ferramentas especificadas nos arquivos do repositório. Para encontrá-las, use os seguintes comandos dentro do diretório do projeto:\n- **Node.js:** Verifique no arquivo `package.json`. Comando: `cat package.json | grep -A4 engines | grep node`.\n- **Yarn:** O `package.json` também especifica o uso do `yarn` em vez do `npm`.\n- **Meteor:** A versão exata está no arquivo `.meteor/release`. Comando: `cat apps/meteor/.meteor/release`.\n- **Deno:** Verifique no arquivo `.tool-versions`. Comando: `cat.tool-versions | grep deno`.\n\n### 3. Métodos de Implantação\n\nPara ambientes de produção, os métodos oficialmente recomendados são baseados em contêineres.\n\n- **Docker & Docker Compose:** É o método preferencial para garantir um ambiente consistente e obter suporte oficial.\n- **Kubernetes (usando Helm):** Ideal para escalabilidade e alta disponibilidade. Os pré-requisitos para deploy com Kubernetes são :\n  - Um cluster Kubernetes funcional.\n  - Helm v3 instalado.\n  - Um **Ingress Controller** (como `ingress-nginx`) para gerenciar o tráfego externo.\n  - Uma **Storage Class** para provisionamento de volumes persistentes.\n  - Para produção, o MongoDB deve ser implantado separadamente (fora do cluster) como um replica set.\n\nOutros métodos como **Snaps**, **instalação direta no SO** (Ubuntu, Debian, etc.) e **marketplaces de nuvem** (Digital Ocean, AWS) estão disponíveis, mas os Snaps não são recomendados para produção, e o suporte oficial prioriza as instalações via Docker.\n\n### 4. Requisitos de Rede e Segurança\n\n- **Domínio:** Você precisa de um nome de domínio apontando para o IP do seu servidor.\n- **Firewall:** A porta HTTPS (443) deve estar aberta. Além disso, pode ser necessário adicionar à lista de permissões (whitelist) os domínios dos serviços em nuvem do Rocket.Chat para garantir o funcionamento de notificações push e do marketplace.\n- **TLS/SSL (HTTPS):** É altamente recomendado configurar um certificado TLS/SSL para comunicação segura. Em Kubernetes, o `cert-manager` pode ser usado para automatizar a emissão de certificados com Let's Encrypt."
  },
  {
    "question": "Como acompanhar o histórico de mudanças do projeto?",
    "answer": "Para acompanhar o histórico de mudanças do projeto Rocket.Chat de forma eficaz, é importante entender que não há um único local que centralize tudo. A melhor abordagem depende do seu objetivo e do nível de detalhe que você precisa.\n\nAqui estão os principais métodos que você pode usar, do mais geral ao mais específico:\n\n### 1. Documentação Oficial e Página de Releases do GitHub\n\nEsta é a forma mais comum e recomendada para a maioria dos usuários e desenvolvedores que desejam entender as mudanças consolidadas em cada versão.\n\n- **Release Notes na Documentação Oficial**: A documentação oficial do Rocket.Chat possui uma seção de \"Release Notes\" separada para cada produto principal:\n  - **Servidor**: Detalha as novidades, correções de bugs e melhorias de performance do core da plataforma. Você pode encontrá-las em `docs.rocket.chat/docs/rocketchat-release-notes`.\n  - **Desktop App**: Foca nas atualizações do cliente para Windows, macOS e Linux. Disponível em `docs.rocket.chat/docs/desktop-release-notes`.\n  - **Mobile App**: Cobre as mudanças para os aplicativos iOS e Android. Disponível em `docs.rocket.chat/docs/mobile-release-notes`.\n  Esta é a melhor fonte para uma visão geral e de alto nível das mudanças.\n\n- **Página de \"Releases\" no GitHub**: Para um mergulho técnico, a página de \"Releases\" no repositório `RocketChat/Rocket.Chat` é a fonte da verdade. Cada release (ex: `7.8.0`) contém:\n  - As versões exatas das dependências (Node.js, MongoDB).\n  - Um log de mudanças detalhado, com links diretos para os Pull Requests (PRs) e issues que implementaram cada alteração.\n  - Uma lista de todos os pacotes internos do monorepo que foram atualizados.\n\n### 2. Análise Direta do Repositório\n\nPara desenvolvedores que contribuem ou precisam de um entendimento profundo do fluxo de trabalho, analisar os arquivos do repositório é essencial.\n\n- **Arquivos `HISTORY.md` e `CHANGELOG.md`**:\n  - O repositório principal (`RocketChat/Rocket.Chat`) possui um arquivo `HISTORY.md` na raiz, embora ele possa não ser tão detalhado quanto as releases do GitHub.\n  - Outros repositórios, como o do cliente de desktop (`Rocket.Chat.Electron`), mantêm um arquivo `CHANGELOG.md` bem estruturado, que agrupa as mudanças por versão e tipo (Bug Fixes, New Features).\n\n- **O Diretório `.changeset`**: Esta é a forma mais avançada e *proativa* de acompanhar as mudanças. O Rocket.Chat utiliza a ferramenta \"Changesets\" para gerenciar o versionamento em seu monorepo.\n  - **Como funciona**: Quando um desenvolvedor faz uma alteração que precisa ser registrada no changelog, ele cria um arquivo markdown dentro do diretório `.changeset`. Esse arquivo descreve a mudança e o tipo de impacto (patch, minor, major).\n  - **Sua utilidade**: Ao inspecionar os arquivos dentro de `.changeset`, você pode ver exatamente quais mudanças estão na fila para serem incluídas na *próxima* versão, antes mesmo dela ser oficialmente lançada.\n\n### 3. Monitoramento Contínuo com a Integração do GitHub\n\nPara um acompanhamento em tempo real, a melhor abordagem é usar a própria plataforma Rocket.Chat.\n\n- **GitHub App**: O Rocket.Chat oferece uma integração oficial com o GitHub que permite que você receba notificações sobre a atividade do repositório diretamente em um canal.\n  - **Como usar**: Após instalar o App, você pode usar o comando `/github subscribe RocketChat/Rocket.Chat` em um canal para receber mensagens automáticas sobre novos commits, issues, pull requests, comentários e merges.\n  - Isso transforma o histórico de mudanças de um registro estático em um fluxo de informações dinâmico e colaborativo, ideal para equipes de desenvolvimento que precisam estar sempre sincronizadas.\n\n### Resumo\n\n| Método | Granularidade | Frequência | Ideal Para | Fonte Principal |\n| :--- | :--- | :--- | :--- | :--- |\n| **Release Notes (Docs)** | Baixa (Resumos) | Por Versão | Administradores e usuários finais | `docs.rocket.chat` |\n| **Releases (GitHub)** | Alta (Técnica) | Por Versão | Desenvolvedores analisando versões | `github.com/RocketChat/Rocket.Chat/releases` |\n| **Arquivos de Histórico** | Média | Por Versão | Verificação rápida em subprojetos | `HISTORY.md`, `CHANGELOG.md` |\n| **Diretório `.changeset`** | Altíssima | Pré-release | Contribuidores prevendo a próxima versão | Diretório `.changeset/*.md` |\n| **Integração GitHub** | Em Tempo Real | Contínua | Equipes de desenvolvimento ativas | Slash command `/github subscribe` |\n\nPara uma compreensão completa, recomendo combinar a consulta à página de **Releases do GitHub** para marcos importantes e a **Integração do GitHub App** para o acompanhamento diário."
  },
  {
    "question": "Qual versão estável mais recente?",
    "answer": "A versão estável mais recente do Rocket.Chat, de acordo com a página de Releases do repositório oficial, é a **7.8.2**.\n\nEsta versão foi lançada em 20 de julho de 2025 e é a mais recente que não está marcada como pré-lançamento (pre-release).\n\nAqui estão alguns detalhes técnicos importantes sobre a versão **7.8.2**, retirados da sua página de lançamento no GitHub :\n\n- **Versões do Motor:**\n  - **Node:** `22.14.0`\n  - **Deno:** `1.43.5`\n  - **MongoDB:** `5.0, 6.0, 7.0`\n  - **Apps-Engine:** `1.53.0`\n\n- **Principais Alterações (Patch Changes):**\n  - Atualização da versão do pacote `@rocket.chat/meteor`.\n  - Correção de um problema que impedia a propagação de prioridades e alterações de SLA quando os fluxos de alteração não estavam em uso.\n\nPara mais detalhes, você pode consultar diretamente a seção \"Releases\" no repositório `RocketChat/Rocket.Chat`."
  },
  {
    "question": "Qual conduta de projeto adotam?",
    "answer": "O projeto Rocket.Chat adota um Código de Conduta formal para garantir um ambiente aberto, acolhedor e livre de assédio para todos os seus participantes. Esta conduta é baseada no **Contributor Covenant, versão 1.4**.\n\nA seguir estão os principais pontos da conduta adotada, extraídos do arquivo `CODE_OF_CONDUCT.md`:\n\n### Compromisso Principal\nO projeto se compromete a proporcionar uma experiência de participação livre de assédio para todos, independentemente de idade, tamanho corporal, deficiência, etnia, identidade e expressão de gênero, ou nível de experiência.\n\n### Padrões de Comportamento Esperado\nOs participantes devem contribuir para um ambiente positivo através de ações como:\n- Usar linguagem acolhedora e inclusiva.\n- Respeitar diferentes pontos de vista e experiências.\n- Aceitar críticas construtivas de forma graciosa.\n- Focar no que é melhor para a comunidade.\n- Demonstrar empatia para com outros membros.\n\n### Comportamentos Inaceitáveis\nA conduta proíbe estritamente:\n- Uso de linguagem ou imagens sexualizadas e atenção sexual indesejada.\n- Trolling, comentários insultuosos, e ataques pessoais ou políticos.\n- Assédio público ou privado.\n- Publicação de informações privadas de outros sem permissão explícita.\n- Qualquer outra conduta considerada inadequada em um ambiente profissional.\n\n### Responsabilidades e Aplicação\n- **Mantenedores do Projeto**: São responsáveis por clarificar e aplicar o Código de Conduta. Eles têm o direito e a responsabilidade de remover, editar ou rejeitar contribuições que não sigam estas regras, e podem banir contribuidores de forma temporária ou permanente.\n- **Denúncias**: Casos de comportamento abusivo ou assediador podem ser reportados à equipe do projeto através do e-mail `team@rocket.chat`. Todas as denúncias são investigadas com a garantia de confidencialidade para o relator.\n- **Escopo**: O Código de Conduta se aplica tanto dentro dos espaços do projeto (repositórios, etc.) quanto em espaços públicos onde um indivíduo esteja representando o projeto."
  },
  {
    "question": "Há integrações disponíveis?",
    "answer": "Sim, o Rocket.Chat é uma plataforma altamente extensível e oferece várias formas de integração para conectar-se a outros serviços, automatizar tarefas e desenvolver novas funcionalidades. As principais maneiras de fazer isso são através de Webhooks, APIs e o Apps Engine.\n\n### 1. Integrações via Webhooks\n\nWebhooks são a forma mais direta de integração, permitindo que serviços externos se comuniquem com o Rocket.Chat através de requisições HTTP POST. Existem dois tipos :\n\n- **Incoming Webhooks (Webhooks de Entrada):** Permitem que uma aplicação externa envie uma mensagem para um canal ou usuário no Rocket.Chat.\n- **Outgoing Webhooks (Webhooks de Saída):** Permitem que o Rocket.Chat envie dados para uma URL externa em resposta a gatilhos, como mensagens que correspondem a um padrão.\n\nAmbos podem ser aprimorados com **scripts em `ES2015 / ECMAScript 6`**, que permitem processar os dados da requisição para customizar a mensagem, alterar o canal de destino ou até mesmo cancelar a operação. A configuração é feita no painel de administração, em `Administração > Integrações`.\n\nPara exemplos práticos, o repositório **`RocketChat/Rocket.Chat.Integrations`** contém uma coleção de scripts prontos para integrar com serviços populares como GitHub, GitLab, Giphy e Telegram.\n\n### 2. APIs Programáticas e SDKs\n\nPara integrações mais complexas e desenvolvimento de bots, o Rocket.Chat oferece APIs robustas:\n\n- **REST API:** Ideal para operações de gerenciamento, como criar usuários, gerenciar salas e enviar mensagens. As especificações da API são formalmente definidas no formato OpenAPI (Swagger) e podem ser encontradas no repositório **`RocketChat/Rocket.Chat-Open-API`**. Este repositório contém arquivos de definição como `messaging.yaml` e `user-management.yaml`, detalhando os endpoints disponíveis.\n\n- **Realtime API:** Utiliza **WebSockets** para comunicação em tempo real, sendo a escolha ideal para bots que precisam reagir a eventos instantaneamente. A conexão é feita no endpoint `wss://[seu-servidor]/websocket` e utiliza um modelo de RPC (Remote Procedure Call) para executar métodos e se inscrever em eventos. A documentação de referência pode ser encontrada em `developer-docs/reference/api/realtime-api/README.md`.\n\nPara facilitar o uso dessas APIs, existem SDKs oficiais:\n- **`Rocket.Chat.js.SDK`:** Uma biblioteca para JavaScript/TypeScript, projetada para a criação de bots e aplicações, que abstrai a comunicação com as APIs REST e Realtime.\n- **`Rocket.Chat.Go.SDK`:** Um SDK para desenvolvedores que utilizam a linguagem Go, também com suporte para ambas as APIs.\n\n### 3. Apps Engine (Motor de Aplicativos)\n\nEsta é a forma mais avançada e poderosa de estender a plataforma. O Apps Engine é um framework que permite criar aplicativos que rodam **dentro** do próprio Rocket.Chat, distribuídos através do Marketplace.\n\nUm aplicativo construído com o Apps Engine pode :\n- **Ouvir eventos** de mensagens e salas (antes e depois de serem criados, atualizados ou deletados).\n- **Registrar novos comandos de barra** (`/slash-commands`).\n- **Criar novos endpoints HTTP**, dando ao aplicativo sua própria API.\n- **Enviar mensagens** para usuários e visitantes do Livechat.\n- **Armazenar dados** e gerenciar configurações próprias.\n\nO código-fonte e a documentação do framework estão disponíveis no repositório **`RocketChat/Rocket.Chat.Apps-engine`**."
  },
  {
    "question": " O que o arquivo data/rocketchat_repo/apps/meteor/server/main.ts implementa?",
    "answer": "O arquivo `apps/meteor/server/main.ts` é o **ponto de entrada (entrypoint) principal e o orquestrador de inicialização** de toda a aplicação do lado do servidor do Rocket.Chat. Sua função é garantir que todos os módulos, configurações e serviços essenciais sejam carregados e iniciados na ordem correta.\n\nA análise do código-fonte do arquivo `apps/meteor/server/main.ts` revela um processo de inicialização em duas fases principais:\n\n**1. Importação de Módulos para Efeito Colateral:**\n\nPrimeiramente, o arquivo importa uma série de módulos essenciais. Em um ambiente Meteor, importar um arquivo no escopo do servidor é suficiente para que seu código seja executado e seus componentes (como métodos, publicações e configurações) sejam registrados na aplicação. Os módulos importados incluem:\n\n*   `./tracing`: Para inicializar o sistema de tracing e monitoramento de performance.\n*   `./models`: Para registrar os modelos de dados com o banco de dados.\n*   `./settings`: Para carregar e aplicar as configurações da aplicação.\n*   `./routes`: Para definir as rotas do lado do servidor.\n*   `./methods` e `./publications`: Para registrar os métodos RPC (Remote Procedure Call) e as publicações de dados do Meteor, que são a base da comunicação em tempo real.\n*   `../lib/oauthRedirectUriServer` e `./lib/pushConfig`: Para configurar funcionalidades específicas como o redirecionamento de OAuth e as notificações push.\n*   `./features/EmailInbox/index`: Para inicializar funcionalidades específicas, como a caixa de entrada de e-mails.\n\n**2. Execução da Sequência de Inicialização Assíncrona:**\n\nApós o registro dos componentes básicos, o arquivo executa uma sequência de funções assíncronas para iniciar os principais serviços da aplicação. O trecho de código a seguir é o coração da orquestração:\n\n```typescript\nawait Promise.all();\n\nawait startRocketChat();\nawait startupApp();\nawait startRestAPI();\n```\n\nEste bloco de código implementa a seguinte lógica:\n\n*   **Inicialização em Paralelo**: Utiliza `Promise.all` para executar três processos de inicialização concorrentemente, otimizando o tempo de startup:\n    *   `configureServer(settings)`: Aplica as configurações ao servidor.\n    *   `registerServices()`: Registra os serviços da aplicação no contêiner de injeção de dependência.\n    *   `startup()`: Executa rotinas de inicialização gerais.\n*   **Inicialização Sequencial**: Após a conclusão das tarefas paralelas, ele inicia os sistemas principais em uma ordem específica e dependente:\n    *   `await startRocketChat()`: Inicia o núcleo da aplicação Rocket.Chat.\n    *   `await startupApp()`: Importado de `../ee/server`, esta função é responsável por iniciar os recursos da **Enterprise Edition (EE)** da plataforma.\n    *   `await startRestAPI()`: Por fim, inicia a API REST, tornando os endpoints acessíveis para clientes externos.\n\nEm resumo, o `apps/meteor/server/main.ts` não contém lógica de negócios, mas atua como o maestro que rege a sinfonia de inicialização do servidor Rocket.Chat, garantindo que a plataforma se torne totalmente operacional de forma estruturada e ordenada."
  },
  {
    "question": "O que o arquivo data/rocketchat_repo/apps/meteor/app/authentication/server/index.ts faz?",
    "answer": "Com base no conteúdo fornecido, o arquivo `data/rocketchat_repo/apps/meteor/app/authentication/server/index.ts` funciona como o ponto de entrada principal (ou \"barrel file\") para o módulo de autenticação do lado do servidor no Rocket.Chat. Sua função não é conter lógica de negócios, mas sim orquestrar a inicialização do módulo de autenticação importando outros arquivos cruciais.\n\nO conteúdo do arquivo é:\n\n```typescript\nimport './hooks/login';\nimport './startup';\n```\n\nIsso revela um padrão de design claro e modular:\n\n1.  **`import './hooks/login';`**: Esta linha carrega e executa o código do arquivo `hooks/login.ts`. O nome \"hooks\" sugere que este arquivo implementa callbacks que se integram ao processo de login do Meteor. Sua responsabilidade provável é executar ações personalizadas durante ou após a autenticação de um usuário, como sincronizar dados, verificar permissões adicionais ou registrar eventos de login.\n\n2.  **`import './startup';`**: Esta linha carrega e executa o código do arquivo `startup.ts`. Em aplicações Meteor, arquivos com o nome `startup` normalmente contêm lógica que precisa ser executada uma única vez, quando o servidor é iniciado. No contexto da autenticação, este arquivo é o local ideal para registrar as configurações dos provedores de autenticação (como OAuth, SAML, LDAP) [1, 2] e definir as configurações globais de segurança relacionadas a contas, como bloqueio por tentativas de login falhas.[2]\n\nEm resumo, o arquivo `apps/meteor/app/authentication/server/index.ts` atua como um orquestrador minimalista. Ele garante que todos os componentes necessários para a autenticação do lado do servidor — tanto as rotinas de inicialização quanto os hooks dinâmicos de login — sejam carregados e executados na ordem correta, mantendo o código do módulo organizado e coeso."
  },
  {
    "question": "O que faz a função startRestAPI? em data/rocketchat_repo/apps/meteor/app/api/server/api.ts",
    "answer": "A função `startRestAPI`, localizada no arquivo `apps/meteor/app/api/server/api.ts`, é responsável por inicializar e configurar a API REST do Rocket.Chat. Ela essencialmente conecta uma série de middlewares que processam as requisições HTTP recebidas antes que elas atinjam os endpoints específicos da API.\n\nAnalisando o código, o processo de inicialização encadeia os seguintes middlewares na seguinte ordem:\n\n1.  **`remoteAddressMiddleware`**: Este é o primeiro middleware no pipeline. Sua função é provavelmente extrair e padronizar o endereço de IP do cliente que está fazendo a requisição, tornando essa informação acessível para os middlewares e rotas subsequentes.\n\n2.  **`cors(settings)`**: Em seguida, é aplicado o middleware de CORS (Cross-Origin Resource Sharing). Ele utiliza as configurações (`settings`) definidas no sistema para adicionar os cabeçalhos HTTP necessários que permitem ou bloqueiam requisições de diferentes origens (domínios). Isso é uma medida de segurança fundamental para controlar como a API pode ser acessada a partir de aplicações web rodando em outros domínios.\n\n3.  **`loggerMiddleware(logger)`**: Este middleware é responsável por registrar informações sobre as requisições recebidas. Utilizando uma instância de `logger`, ele provavelmente grava detalhes como o método da requisição, a URL, o status da resposta e o tempo de processamento, o que é vital para depuração e monitoramento.\n\n4.  **`metricsMiddleware(...)`**: Configura a coleta de métricas para o Prometheus. Ele monitora as requisições que correspondem à expressão regular `^/api/v1/`, ou seja, todas as rotas da v1 da API. As métricas coletadas, como o número de requisições e a latência, são armazenadas no objeto `metrics.rocketchatRestApi` e podem ser expostas em um endpoint para serem coletadas por um servidor Prometheus, permitindo o monitoramento da saúde e do desempenho da API.\n\n5.  **`tracerSpanMiddleware`**: Este middleware é utilizado para implementar o rastreamento distribuído (distributed tracing). Ele provavelmente cria \"spans\" para cada requisição, que são unidades de trabalho em uma transação. Isso permite rastrear o fluxo de uma requisição através de diferentes serviços e componentes do Rocket.Chat, facilitando a identificação de gargalos de performance.\n\n6.  **`API.v1.router`**: Após passar por todos os middlewares de preparação, a requisição é direcionada para o roteador da **versão 1** da API. Este roteador é responsável por mapear a URL e o método HTTP da requisição para o código do controlador correspondente que executa a lógica de negócio específica do endpoint (por exemplo, `/api/v1/users.info`).\n\n7.  **`API.default.router`**: Se a requisição não corresponder a nenhuma rota definida no `API.v1.router`, ela é então passada para o roteador padrão (`API.default.router`). Este roteador geralmente lida com rotas que não fazem parte de uma versão específica da API ou serve como um \"catch-all\" para retornar erros 404 para endpoints não encontrados.\n\nEm resumo, a função `startRestAPI` configura o \"encanamento\" pelo qual todas as chamadas à API REST devem passar, garantindo que elas sejam validadas, logadas, monitoradas e roteadas corretamente para a lógica de aplicação apropriada."
  },
  {
    "question": "Para que serve scripts/start.sh?",
    "answer": "Olá!\n\nAnalisei o repositório e confirmo que o arquivo `scripts/start.sh` não existe na estrutura do projeto Rocket.Chat.\n\nA ausência desse script é uma decisão de design intencional. O Rocket.Chat não utiliza um único comando de inicialização universal porque o método para iniciar o servidor está diretamente ligado à forma como ele foi implantado. Cada método de implantação é otimizado para um cenário de uso específico, desde o desenvolvimento local até a produção em larga escala.\n\nAqui estão os principais métodos para iniciar o Rocket.Chat, dependendo do ambiente:\n\n1.  **Ambiente de Desenvolvimento Local:**\n    *   O comando principal é `yarn dsv`. Este script, definido no arquivo `package.json` na raiz do projeto, é responsável por compilar todos os ativos necessários e iniciar o servidor Meteor em modo de desenvolvimento, que inclui funcionalidades como hot-reloading para agilizar as alterações no código.[1]\n\n2.  **Implantação Manual em Servidor Linux (Bare-metal com `systemd`):**\n    *   Neste cenário, o Rocket.Chat é gerenciado como um serviço do sistema. O comando que efetivamente inicia a aplicação é `node main.js`, mas ele não é executado diretamente. Em vez disso, ele é definido na diretiva `ExecStart` dentro de um arquivo de serviço, como `rocketchat.service`.[2]\n    *   O administrador do sistema gerencia o ciclo de vida da aplicação usando comandos do `systemd`, como `sudo systemctl start rocketchat` para iniciar o serviço e `sudo systemctl enable rocketchat` para que ele inicie com o boot do sistema.[2]\n\n3.  **Implantação com Docker e Docker Compose (Método Recomendado):**\n    *   Esta é a forma mais popular e recomendada para produção.[3] A inicialização é feita com o comando `docker compose up -d`.[4, 5]\n    *   Este comando lê as definições dos serviços (a aplicação Rocket.Chat e o banco de dados MongoDB) do arquivo `compose.yml` e as variáveis de configuração do arquivo `.env` para orquestrar a criação e execução dos contêineres.[4, 5]\n\n4.  **Implantação em Larga Escala com Kubernetes (Helm):**\n    *   Para ambientes que exigem alta disponibilidade e escalabilidade, a implantação é feita em um cluster Kubernetes usando o gerenciador de pacotes Helm.[3]\n    *   O comando de inicialização é `helm install rocketchat rocketchat/rocketchat -f values.yaml`, que utiliza o chart oficial do Rocket.Chat e um arquivo `values.yaml` para personalizar a implantação.[6]\n\nEm resumo, a maneira de \"dar start\" no Rocket.Chat depende fundamentalmente da sua arquitetura de implantação. A resposta está nas ferramentas de orquestração e gerenciamento de cada método (Yarn, Systemd, Docker Compose, Helm), e não em um script `start.sh` genérico."
  },
  {
    "question": "O que o arquivo README.md apresenta?",
    "answer": "O arquivo `README.md` do repositório `Rocket.Chat` apresenta uma visão geral completa sobre o projeto, destacando suas funcionalidades, formas de implantação, documentação oficial e maneiras de contribuir com a comunidade.\n\nEle começa com a apresentação visual da marca Rocket.Chat e uma breve descrição do projeto como uma plataforma de comunicação totalmente personalizável, open-source, desenvolvida em JavaScript. O Rocket.Chat é posicionado como uma solução gratuita e segura para comunicação em equipe, utilizada por milhões de usuários em mais de 150 países.\n\nO documento destaca quatro principais ofertas de produto:\n\n- **Colaboração em equipe** (Team collaboration)\n- **Atendimento ao cliente omnichannel** (Omnichannel customer service)\n- **Motor de chat personalizável** (Chat engine)\n- **Marketplace de apps e integrações** (Marketplace)\n\nTambém são detalhadas opções de hospedagem, com um link para informações sobre a versão em nuvem (cloud-hosted).\n\nO `README.md` fornece links para documentação de usuários, desenvolvedores e administradores, além de instruções específicas para configurar um ambiente de desenvolvimento local em diferentes sistemas operacionais (Linux, MacOS, Windows 10 e Gitpod).\n\nPara quem deseja implantar o Rocket.Chat, o arquivo orienta consultar os requisitos do sistema e o guia de instalação. Há também informações sobre os aplicativos móveis disponíveis na App Store e Google Play, além do repositório open-source específico para os clientes móveis (`Rocket.Chat.ReactNative`).\n\nO documento menciona a possibilidade de desenvolver integrações via Apps Engine, fornece links para aprender mais sobre a plataforma, sugere canais para enviar solicitações de funcionalidades, e convida os usuários a participarem da comunidade e contribuírem com o projeto. Por fim, há uma seção de oportunidades de emprego e de canais oficiais de comunicação como blog, redes sociais e YouTube.\n\nTodo o conteúdo é focado em orientar novos usuários e desenvolvedores, oferecendo múltiplos caminhos para explorar, usar, contribuir e interagir com o ecossistema Rocket.Chat."
  }
]
